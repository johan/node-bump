// Generated by CoffeeScript 1.8.0
(function() {
  var DIST_TAGS, argDWIM, dep, dependencyVersion, fail, fetchPackageVer, format, fs, getVersion, json, log, newVersion, oldVersion, packageUrl, path, pkg, program, raw, request, semver, setVer, target, ver,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  semver = require('semver');

  request = require('request');

  format = require('format-json');

  program = require('commander');

  raw = fs.readFileSync('package.json', 'utf8');

  pkg = JSON.parse(raw);

  log = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (program.verbose && !program.quiet) {
      return console.log.apply(console, args);
    }
  };

  fail = function() {
    var args, exitCode;
    exitCode = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (typeof exitCode !== 'number') {
      args.unshift(exitCode);
      exitCode = 1;
    }
    if (!program.quiet) {
      console.error.apply(console, args);
    }
    return process.exit(exitCode);
  };

  program.version(require('../package').version).option('-q, --quiet', 'quiet mode').option('-v, --verbose', 'verbose mode').option('-p, --patch', 'bump patch version [default]').option('-m, --minor', 'bump minor version').option('-M, --major', 'bump major version').option('-t, --to <version>', 'explicit version to bump to').option('-b, --bump [name]', 'package property to bump: [version]', 'version').option('-d, --dependency [package]', 'what (dev?)dependency to bump').option('-l, --latest', 'for a package dependency, bump to latest version').option('-B, --beta', 'for a package dependency, bump to latest beta').option('-f, --force', 'proceeds even if the given version is a bump backwards').option('-n, --no-edit', 'do not actually write package.json; just simulate it').parse(process.argv);

  DIST_TAGS = ['latest', 'beta'];

  if (program.latest) {
    newVersion = 'latest';
  }

  if (program.beta) {
    newVersion = 'beta';
  }

  newVersion || (newVersion = ver = program.to);

  if (ver && !semver.valid(ver)) {
    fail("Not a SemVer-legal version:", ver);
  }

  argDWIM = program.args.shift();

  if (semver.valid(argDWIM)) {
    newVersion || (newVersion = argDWIM);
    argDWIM = program.args.shift();
  }

  dependencyVersion = function(name) {
    var valid, version;
    version = pkg.dependencies[name] || pkg.devDependencies[name];
    if (version == null) {
      fail('package.json has no dependency or devDependency:', name);
    }
    if (valid = semver.valid(version)) {
      return valid;
    }
    if (valid = semver.valid(version.split('#v')[1])) {
      return valid;
    }
    if (!newVersion) {
      return fail("Failed to decode old version number from: " + version);
    }
  };

  oldVersion = pkg[program.bump];

  if (dep = program.dependency) {
    oldVersion = dependencyVersion(dep);
  }

  if (!dep && (dep = argDWIM)) {
    oldVersion = dependencyVersion(dep);
  }

  target = function() {
    return dep || ("package.json:" + program.bump);
  };

  setVer = function(newVersion) {
    var me;
    me = target();
    if (!program.force && semver.lt(newVersion, oldVersion)) {
      fail(3, "Use --force to downgrade " + me + " from " + oldVersion + " to " + newVersion);
    }
    log(me, oldVersion, '=>', newVersion);
    if (dep == null) {
      return pkg[program.bump] = newVersion;
    }
    if (pkg.dependencies[dep]) {
      return pkg.dependencies[dep] = newVersion;
    }
    if (pkg.devDependencies[dep]) {
      return pkg.devDependencies[dep] = newVersion;
    }
    return fail("No such package.json dependency:", dep);
  };

  packageUrl = function(name) {
    var repo, _ref, _ref1;
    repo = (_ref = (_ref1 = pkg.publishConfig) != null ? _ref1.registry : void 0) != null ? _ref : 'https://registry.npmjs.org';
    if (repo.slice(-1) !== '/') {
      repo += '/';
    }
    return repo + name;
  };

  fetchPackageVer = function(name, channel, cb) {
    var url;
    url = packageUrl(name);
    return request({
      url: url,
      json: true
    }, function(err, res) {
      var tags, version;
      if ((err != null) || !(res != null ? res.body : void 0)) {
        fail("" + url + ": missing response body");
      }
      tags = res.body['dist-tags'];
      if (version = tags != null ? tags[channel] : void 0) {
        return cb(version);
      } else {
        return fail("Package '" + dep + "' has no '" + channel + "' dist-tag:", tags);
      }
    });
  };

  getVersion = function(done) {
    var bump;
    if (program.patch) {
      bump = 'patch';
    }
    if (program.minor) {
      bump = 'minor';
    }
    if (program.major) {
      bump = 'major';
    }
    if (dep && !bump) {
      newVersion || (newVersion = 'latest');
    }
    if (newVersion) {
      if (__indexOf.call(DIST_TAGS, newVersion) >= 0) {
        if (!dep) {
          fail("Please state --dependency <package> for --" + newVersion);
        }
        return fetchPackageVer(dep, newVersion, done);
      } else {
        return done(newVersion);
      }
    }
    return done(semver.inc(oldVersion, bump || 'patch'));
  };

  if (!oldVersion && !newVersion) {
    fail("package.json:" + program.bump + " property unset, and no --to version given!");
  }

  json = function(x) {
    var all, line, linePlusBreak, match, matchLine, newlines, property, res, stringify;
    matchLine = function(property, newlines) {
      if (newlines == null) {
        newlines = '';
      }
      return RegExp("([\\x20\\[\\{,]*\"" + property + "\":[^\\n]*[\\s\\]\\},]*[^\\n])(\\n" + newlines + ")", "gm");
    };
    stringify = raw.slice(0, 3) === '{ "' ? format.diffy : format.plain;
    res = stringify(x);
    if (raw.slice(-1) === '\n') {
      res += '\n';
    }
    linePlusBreak = matchLine('([^"\\n]*)', '{2,}');
    while (match = linePlusBreak.exec(raw)) {
      all = match[0], line = match[1], property = match[2], newlines = match[3];
      res = res.replace(matchLine(property), '$1' + newlines);
    }
    return res;
  };

  getVersion(function(newVersion) {
    if (oldVersion === newVersion) {
      process.exit(2);
    }
    setVer(newVersion);
    if (!program.noEdit) {
      fs.writeFileSync('package.json', json(pkg));
    }
    return process.exit(0);
  });

}).call(this);
